{"type":"lab","chapters":[{"title":"#Objectives","shortTitle":"Lab-09a","contentMd":"#Objectives\n\nCollections · Generic Classes · ArrayList · loops · for each loop · Menu Driven Apps\n"},{"title":"#Starting ShopV3.0","shortTitle":"01","contentMd":"#Starting ShopV3.0\n\nIn this step, you will use the ShopV2.1 solution as a starting point for Shop V3.0.  In this version:\n\n- you will remove the primitive array and use an ArrayList instead.\n\n- when you are successfully using an ArrayList, you will then add a menu to control the user interaction with your app.\n\n\n##Creating ShopV3.0\n\nThe solution to the previous lab (i.e. ShopV2.1) is [here](./archives/ShopV2.1.zip).\n\nIn IntelliJ, create a new project called ShopV3.0.  \n\nCopy the src files (Driver, Store, Product) from ShopV2.1 and paste them in the src for ShopV3.0.\n\n![ShopV3.0 folder structure](./img/01.PNG)\n\n\n##Test the code base\n\nRun your version of ShopV3.0 to both test it and also familiarise yourself with the project. \n\n"},{"title":"#Refactoring the Store Class","shortTitle":"02","contentMd":"#Refactoring the Store Class\n\nIn this step, you will refactor (change) the Store class so that it no longer uses a primitive array, but uses an ArrayList instead.\n\n\n##Import the ArrayList class\n\nTo use the ArrayList in our Store class, we need to import it:\n\n~~~java\nimport java.util.ArrayList;\n~~~\n\n\n##Declaring an ArrayList\n\nCurrently we are using a primitive array and we keep track of how many items are added using the **total** field:\n\n~~~java\n\tprivate Product[] products;\n\tprivate int total;\n~~~\n\nAs an ArrayList automatically grows and shrinks as you add/remove elements, there is no need for the **total** field anymore. Delete this field.\n\nThe **products** instance field should be changed to this:\n\n~~~java\n    private ArrayList<Product> products;\n~~~\n\n\n##The Store Constructor\n\nCurrently the Store constructor looks like this:\n\n~~~java\n\tpublic Store(int numberItems){\n\t\tproducts = new Product[numberItems];\n\t\ttotal = 0;\n\t}\n~~~\n\nAs an ArrayList doesn't need to know the maximum number of items that will be stored, we can delete the parameter **numberItems**.  We can also remove the initialisation of **total**.  We will instantiate the **products** ArrayList too, instead of a primitive array instantiation.  Your constructor should now look like this:\n\n~~~java\n\tpublic Store(){\n\t\tproducts = new ArrayList<Product>();\n\t}\n~~~\n\n\n##The add method\n\nCurrently the **add** method looks something like this (see code below).  As a primitive array has a maximum capacity, you have to check if the array is full before attempting to add a Product to it.  As the add can fail due to space restrictions, you also need to return a boolean status for the add.  The total field also needed to be maintained.\n\n~~~java\n\t    public boolean add(Product product){\n        if (isFull()){\n            return false;\n        }\n        else{\n            products[total] = product;\n            total++;\n            return true;\n        }\n    }\n~~~\n\nAs the ArrayList grows when you add Product objects to it, you don't need to check for spare capacity, check for successful adds, nor do you have to maintain the total items entered (an ArrayList does this for us).  Replace the above **add** method with our new **add** method, which will simply look like this:\n\n~~~java\n    public void add (Product product){\n        products.add (product); \n    }\n~~~\n\n\n##The listProducts method\n\nCurrently the **listProducts** method looks like this:\n\n~~~java\n    public String listProducts(){\n        if (isEmpty()){\n            return \"No products\";\n        }\n        else{\n            String listOfProducts = \"\";\n            for (int i = 0; i < total; i++){\n                listOfProducts = listOfProducts + i + \": \" + products[i] + \"\\n\";\n            }\n            return listOfProducts;\n        }\n    }\n~~~\n\nRewrite the method so that it looks like this:\n\n~~~java\n\tpublic String listProducts(){\n\t\tif (products.size() == 0){\n\t\t\treturn \"No products\";\n\t\t}\n\t\telse{\n\t\t\tString listOfProducts = \"\";\n\t\t\tfor (int i = 0; i < products.size(); i++){\n\t\t\t\tlistOfProducts = listOfProducts + i + \": \" + products.get(i) + \"\\n\";\n\t\t\t}\n\t\t\treturn listOfProducts;\n\t\t} \n\t}\n~~~\n\nOr if you prefer to use the for-each loop, you can replace it with this:\n\n~~~\n    public String listProducts(){\n\t\tif (products.size() == 0){\n\t\t\treturn \"No products\";\n\t\t}\n\t\telse{\n\t\t\tString listOfProducts = \"\";\n\t\t\tint index = 0;\n\t\t\tfor (Product product : products){\n\t\t\t\tlistOfProducts = listOfProducts + index + \": \" + product + \"\\n\";\n\t\t\t\tindex ++;\n\t\t\t}\n\t\t\treturn listOfProducts;\n\t\t} \n\t}\n~~~\n\n\n##The listCurrentProducts method\n\nHaving rewritten the **listProducts** method, refactor the **listCurrentProducts** method body so that it is the exact same.\n\nInclude, inside the for loop, the following test so that only those products in the current product line are added to the String to be returned:\n\n~~~\n    if (products.get(i).isInCurrentProductLine())            \n~~~  \t\t\t\t\n\n\n##The listProductsAboveAPrice method\n\nHaving worked on the other two **list** methods above, have a go at converting **listProductsAboveAPrice** to handle **ArrayList** instead of a **primitive array**.\n\n\n##The averageProductPrice method\n\nCurrently, the **averageProductPrice** method looks like this:\n\n~~~java\n    public double averageProductPrice()\n\t{ \n\t\tif (!isEmpty()){\n\t\t\tdouble totalPrice = 0;\n\t\t\tfor (int i = 0; i < total; i++){\n\t\t\t\ttotalPrice = totalPrice + products[i].getUnitCost();\n\t\t\t}\n\t\t\treturn totalPrice / products.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t}\n~~~\n\nRefactor the method so that it looks like the code below.  Note that we have catered for an empty ArrayList...we don't want to accidentally divide by zero as it will crash our program (DivideByZeroException).\n\n~~~\n\tpublic double averageProductPrice()\n\t{ \n\t\tif (products.size() != 0){\n\t\t\tdouble totalPrice = 0;\n\t\t\tfor (int i = 0; i < products.size(); i++){\n\t\t\t\ttotalPrice = totalPrice + products.get(i).getUnitCost();\n\t\t\t}\n\t\t\treturn totalPrice / products.size();\n\t\t}\n\t\telse{\n\t\t\treturn 0.0;\n\t\t}\n\t}\n~~~\n\n\n##The cheapestProduct method\n\nHaving refactored the previous methods, have a go at converting the **cheapestProduct** method to handle **ArrayList** instead of a **primitive array**.\n\n\n##isEmpty and isFull methods\n\nThere is no need for these methods when using ArrayLists, so you can simply delete them.\n\n\n"},{"title":"#Refactoring the Driver Class","shortTitle":"03","contentMd":"#Refactoring the Driver Class\n\nIn this step, you will refactor (change) the Driver class so that any changes we made to the **Interface** of the Store class are reflected in this class.\n\n\n##Store Constructor\n\nThe only change that we made to the **Interface** of the Store class is the Store Constructor.\n\nBy using an ArrayList, we removed the need to know the size of the collection at the start of the program.  For this reason we deleted the numberItems from the Store constructor's parameter list. \n\nIn the Driver class, in the processOrder method, you will find this code:\n\n~~~java\n    //find out from the user how many products they would like to order\n    System.out.print(\"How many Products would you like to have in your Store?  \");\n    int numberProducts = input.nextInt();\n    \n    store = new Store(numberProducts);\n~~~\n\nFor the moment, leave the code in that asks the user how many products they want to enter (we will come back to this later!).\n\nJust remove the parameter that is passed to the Store constructor.  This line of code should now be:\n\n~~~java\n    store = new Store();\n~~~\n\n\n##Run and Test\n\nTry running your code; the functionality for the user should not have changed in any way.  \n\nYour output should look similar to this:\n\n![Output from ShopV3.0 - no menu](./img/06.PNG)\n\n"},{"title":"#Menu Driven App","shortTitle":"04","contentMd":"#Menu Driven App\n\nAt this stage, you should have refactored ShopV3.0 so that it uses an ArrayList instead of a primitive array.  If you had difficulty with it, [here is an interim solution](./archives/ShopV3.0-InterimSolution.zip) that you can use for the rest of this lab.\n\nYou will notice in our code that we are still asking the user how many products they want to add.  This is very restrictive for a user; they cannot add more products later on.  Our app also doesn't allow them to choose what items they would like to list, etc.  The user has no level of control over our system.\n\nFor this reason, we are going to add a menu to our console app so the user can choose what they would like to do with their products:\n\n![ShopV3.0 menu](./img/07.PNG)\n\nAs the **Driver** class controls all the I/O, our changes will be made in this class; Store and Product will not change.\n\n\n##Driver Class I/O\n\nCurrently, the I/O is controlled by the **main** method with calls to other methods of the Driver class:\n\n~~~java\n    public static void main(String[] args) {\n        Driver c = new Driver();\n        c.processOrder();\n        c.printProduct();\n        c.printCurrentProducts();\n        c.printAverageProductPrice();\n        c.printCheapestProduct();\n        c.printProductsAboveAPrice();\n    }\n~~~\n\nAs we will call these methods from our **menu** code instead, you can delete all of these method calls.  Your main method should now look something like this:\n\n~~~\n    public static void main (String args[]){\n        Driver app = new Driver();\n    }\n~~~\n\n\n##Driver constructor\n\nAdd a **Driver** constructor that creates an object of the **Store** class:\n\n~~~java\n    public Driver(){\n        store = new Store();\n    }\n~~~\n\nYou can now delete the **processOrder** method; the menu will perform this processing for us.\n\n\n##Driver methods (except the add method)\n\nThe following methods (except the add one) print out a bit of information to the user to give them context on the data that is being printed e.g.:\n\n~~~java\n    private void printProduct(){\n        System.out.println(\"List of Products are:\");\n        System.out.println(store.listProducts());\n    }\n    \n    private void printCurrentProducts(){\n        System.out.println(\"List of CURRENT Products are:\");\n        System.out.println(store.listCurrentProducts());\n    }\n    \n    private void printAverageProductPrice(){\n        System.out.println(\"The average product price is: \" + store.averageProductPrice());\n    }\n    \n    private void printCheapestProduct(){\n        System.out.println(\"The cheapest product is:  \" + store.cheapestProduct());\n    }\n\n    private void printProductsAboveAPrice(){\n        System.out.print(\"View the product costing more than this price:  \");\n        double price = input.nextDouble();\n        System.out.println(store.listProductsAboveAPrice(price));\n    }\n~~~\n\nAs the user will select, from a menu system, what they want to print, there is no need for the added detail to be printed out.  \n\nDelete all of these methods (don't delete *add*); instead we will just call the relevant *store.xxx* method directly from the main menu.\n\n\n##mainMenu method\n\nEnter the following code into the Driver class.  This method displays the menu for the application, reads the menu option that the user entered and returns it.\n\n~~~java\n    /**\n     * mainMenu() - This method displays the menu for the application, \n     * reads the menu option that the user entered and returns it.\n     * \n     * @return     the users menu choice\n     */\n    private int mainMenu(){ \n        System.out.println(\"Shop Menu\");\n        System.out.println(\"---------\");     \n        System.out.println(\"  1) Add a Product\");    \n        System.out.println(\"  2) List the Products\");    \n        System.out.println(\"---------\");     \n        System.out.println(\"  3) List the cheapest product\");        \n        System.out.println(\"  4) List the products in our current product line\"); \n        System.out.println(\"  5) Display average product unit cost\"); \n        System.out.println(\"  6) List products that are more expensive than a given price\");     \n        System.out.println(\"  0) Exit\");\n        System.out.print(\"==>> \");\n        int option = input.nextInt();\n        return option;\n    }\n~~~\n\n\n##runMenu method\n\nEnter the following code into the Driver class...this method controls the looping of the menu and calls the appropriate methods based on the user choice:\n\n~~~\n   private void runMenu(){\n       int option = mainMenu();\n       while (option != 0){\n          \n           switch (option){\n              case 1:    addProduct();\n                         break;\n              case 2:    System.out.println(store.listProducts());\n                         break;\n              case 3:    System.out.println(store.cheapestProduct());\n                         break;\n              case 4:    System.out.println(store.listCurrentProducts());\n                         break;\n              case 5:    System.out.println(store.averageProductPrice());\n                         break;\n              case 6:    System.out.print(\"Enter the price barrier: \");\n                         double price = input.nextDouble();\n                         System.out.println(store.listProductsAboveAPrice(price));\n                         break;\n             default:    System.out.println(\"Invalid option entered: \" + option);\n                         break;\n           }\n           \n           //pause the program so that the user can read what we just printed to the terminal window\n           System.out.println(\"\\nPress any key to continue...\");\n           input.nextLine();\n           input.nextLine();  //this second read is required - bug in Scanner class; a String read is ignored straight after reading an int.\n           \n           //display the main menu again\n           option = mainMenu();\n       }\n      \n       //the user chose option 0, so exit the program\n       System.out.println(\"Exiting... bye\");\n       System.exit(0);\n   }\n~~~\n\n\n##Calling the menu\n\nReturn back to your **Driver** constructor and add, as the last statement, a call the runMenu() method e.g.:\n\n~~~java\n    public Driver(){\n        store = new Store();\n        runMenu();\n    }\n~~~\n\n\n##Run the App\n\nRun the app; does all work as expected?  Does each menu option do what it is supposed to do? \n\nTest the menu with some of your own products and see if you can identify any bugs.  If you come across any, try fix them.\n\nBefore moving onto the next step, it is a good idea to familiarise yourself with the code in both the Store and the Driver class.  Note that we made no changes to the Product class. \n\n"},{"title":"#Formatting decimal output","shortTitle":"05","contentMd":"#Formatting decimal output\n\nDid you notice that the average product price is not limited to two decimal places?\n\n![Average product price](./img/08.PNG)\n\n\n##toTwoDecimalPlaces\n\nWe are going to just truncate this to two decimal places.\n\nAdd the following helper method towards the bottom of the Store class:\n\n~~~java\n    private double toTwoDecimalPlaces(double num){\n        return (int) (num *100 ) /100.0; \n    }\n~~~\n\nCurrently, your **averageProductPrice** method should look something like this:\n\n~~~\n    public double averageProductPrice()\n    { \n        if (products.size() != 0){\n            double totalPrice = 0;\n            for (int i = 0; i < products.size(); i++){\n                totalPrice = totalPrice + products.get(i).getUnitCost();\n            }\n            return totalPrice / products.size();\n        }\n        else{\n            return 0.0;\n        }\n    }\n~~~\n\nWhen returning the result of the average calculation, we want to call our new **toTwoDecimalPlaces** method to truncate the result to two decimal places:\n\n~~~java\n    public double averageProductPrice()\n    { \n        if (products.size() != 0){\n            double totalPrice = 0;\n            for (int i = 0; i < products.size(); i++){\n                totalPrice = totalPrice + products.get(i).getUnitCost();\n            }\n            return toTwoDecimalPlaces(totalPrice / products.size());\n        }\n        else{\n            return 0.0;\n        }\n    }\n~~~\n\nMake this change and test your app to make sure your result is truncated to two decimal places.\n\n"},{"title":"#Exercises","shortTitle":"Exercises","contentMd":"#Exercises\n\nOver the next few weeks, we will use the knowledge we glean from the **Shop** project to build a Menu Driven **DVDLibrary** app.  \n\nToday, you will work on Phase 1 of this DVDLibrary application; it presents the user with a simple menu for adding and listing DVD titles.\n\n\n#Menu Driven DVD app - phase 1\n\nCreate a new project called **DVDLibraryV1.0**. \n\n\n##DVD class\n\nWithin this project, create a new class called **DVD**. In this class:\n\n- Add an instance field, called **title**, that will store the title of the DVD.\n\n- Add a default empty constructor (we will cover why in later labs). \n\n- Add a constructor that takes in the title as a parameter and updates the instance field, **title**.\n\n- Add an accessor and a mutator for the **title** field.\n\n- Add a toString method that formats the object state to a user-friendly string.\n       \n\n##Library class\n\nWithin the current project, create a new class called **Library**. In this class:\n\n- Add an instance field called **dvds** that can hold an ArrayList of DVDs.\n\n- Add a constructor that instantiates the above ArrayList.\n\n- Add a method **add()** that accpets a DVD object as a parameter. This method should add the passed DVD object to the **dvds** ArrayList.\n\n- Add a method **listDVDs()** that *returns* a String comprising the index number and the title of each DVD in the dvds ArrayList.  If there are no dvds in the ArrayList, the String \"No DVDs\" should be returned.\n\n\n##Driver class\n\nWithin the current project, create a new class called **Driver**. In this class:\n\n- Add an instance field called **library** that is of type **Library**.\n\n- Add an instance field called **input** that is of type **Scanner**.\n\n- Add a constructor that instantiates the above **library** field and the above **input** field.\n\n- Add a private method called **addDVD()** that has a void return type.  This method should read the title of the DVD from the user.  It should also include the following line of code to add the DVD to the dvds collection in Library:\n\n~~~java\n    library.add(new DVD(dvdTitle));\n~~~ \n\n- NOTE:  This line of code:\n\n    - creates a DVD object with the title entered by the user.\n\n    - calls the **add** method in the Library class to add the DVD object to the **dvds** ArrayList. \n\n\n- Add a private method **mainMenu()** that has an int return type.  This method should display the name of the menu and the menu options (see image below).  This method should read the menu option that the user entered and return it.\n\n![Menu for the DVD Library](./img/09.PNG) \n\n- Add a private method **run()** that has a void return type.  This method should look like this:\n\n~~~java\n    private void run()\n    {\n        int option = mainMenu();\n        while (option != 0)\n        {\n            switch (option)\n            {\n                case 1:\n                    addDVD();\n                    break;\n                case 2:\n                    System.out.println(library.listDVDs());\n                    break;\n                default:\n                    System.out.println(\"Invalid option selected.\");\n                    break;\n            }\n\n            //display the main menu again\n            System.out.println(\"\");\n            option = mainMenu();\n        }\n        System.out.println(\"Exiting... bye\");\n    }\n~~~\n        \n- Finally, write a main method that will create an instance of itself (i.e. the Driver class) and call the **run** method over this instance (see the code below).\n\n~~~java\n    public static void main (String[] args)\n     {\n         Driver app = new Driver();\n         app.run();\n     }\n~~~\n\n\n##Run and Test\n\nRun the project.\n\nTest by adding a series of DVDs and listing them.  \n\nAlso try listing the DVDs when no DVDs have been entered (you can test this by restarting the application to clear any existing DVDs).\n\n\n"},{"title":"#Solutions","shortTitle":"Solutions","contentMd":"#Solutions\n\n[ShopV2.1 from the previous lab](archives/ShopV2.1.zip)\n\n[ShopV3.0-InterimSolution](archives/ShopV3.0-InterimSolution.zip)\n\n[ShopV3.0](archives/ShopV3.0.zip)\n\n[Exercise Solution - DVDLibraryV1.0](archives/DVDLibraryV1.0.zip)\n\n"}]}